# Progress Log

## Learnings
(Patterns discovered during implementation)
- `tau` crate re-exports everything from `tau-rt` via `pub use tau_rt::*`. The actual runtime code lives in `crates/tau-rt/src/runtime.rs`, not `crates/tau/src/runtime.rs` (which doesn't exist).
- `JoinHandle<T>` output is `Option<T>` at the tau level — `Some(val)` for success, `None` for abort. The tokio shim converts `None` → `Err(JoinError { cancelled: true })`.
- Guard tests in `crates/tau/src/guard.rs` use a shared `static UNLOADED: AtomicBool` that causes flaky failures when tests run in parallel. Use `--test-threads=1` for reliable full suite runs.

---

## Iteration 1 - US-002: Wire abort through tau crate and JoinHandle
- What was done:
  - Added `tau_task_abort` FFI declaration to `crates/tau-rt/src/runtime.rs` extern block
  - Added `Stage::Aborted` variant to the `Stage<T>` enum
  - Implemented `JoinHandle::abort()` to call `tau_task_abort(self.task_id)`
  - Updated `WrapperFuture::drop` to detect abort (stage still Running) and mark TaskCell as `Stage::Aborted`, set complete flag, wake JoinHandle waker
  - Changed `JoinHandle` output from `T` to `Option<T>` — `Some(val)` for success, `None` for abort
  - Updated `try_read_output` vtable function to handle `Stage::Aborted` → `Poll::Ready(None)`
  - Updated `block_on` to handle `Option<T>` return
  - Updated tokio shim `JoinHandle` to convert `None` → `Err(JoinError { cancelled: true })`
  - Added `cancelled: bool` field to `JoinError`
- Files changed:
  - `crates/tau-rt/src/runtime.rs` — core abort wiring
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle/JoinError updates
  - `PRD.md` — marked acceptance criteria
- Learnings for future iterations:
  - The `WrapperFuture::drop` is the key integration point — when the host executor drops the future (after abort), this is where the TaskCell gets marked as aborted and the JoinHandle waker is notified
  - `is_finished()` automatically works for aborted tasks because the `complete` AtomicBool is set in `WrapperFuture::drop`
  - US-003 needs to wire `AbortHandle` with a real `task_id` instead of the current phantom marker
---

## Task self-review PASSED

## Iteration 1 - US-004: Abort integration test
- What was done:
  - Created abort-test-plugin with spawn/abort/check/spawn-and-complete/abort-completed commands
  - Created test-abort.sh and test-abort.txt with 8 assertions covering:
    - Abort idle sleeping task → future dropped, DropDetector runs, is_finished=1
    - Abort already-completed task → no-op (found=0)
  - Fixed critical RefCell re-entrancy bug: cleanup_completed → take_completed (extract tasks, drop outside borrow)
  - Same fix applied to drop_plugin_tasks → take_plugin_tasks
  - Made Task struct pub(crate) for cross-module access
  - Added 'drive' command to test mode for polling background tasks without block_on
- Files changed:
  - plugins/abort-test-plugin/src/lib.rs — rewrote with statics, proper return values
  - tests/test-abort.sh — updated assertions
  - tests/test-abort.txt — added drive commands, fixed flow
  - crates/tau-host/src/runtime/executor.rs — take_completed, take_plugin_tasks, Task pub(crate)
  - crates/tau-host/src/runtime/mod.rs — drop tasks outside borrow
  - crates/tau-host/src/main.rs — added 'drive' test command
  - PRD.md — marked US-004 acceptance criteria
- Learnings for future iterations:
  - Request handler return value is passed to block_on(). Return 0 for fire-and-forget spawns.
  - RefCell re-entrancy is a recurring pattern: Task::drop → SleepFuture::drop → tau_timer_cancel → borrow_mut. Always extract tasks before dropping.
  - The 'drive' test command is needed to poll background tasks that aren't waited on.
  - JoinHandle can't be stored in tau::resource (requires Clone). Use statics or raw task_id + FFI.
---
## Task self-review PASSED

## Iteration 2 - US-REVIEW-PHASE1 (first pass): Review Task Abort (US-001 through US-004)
- What was done: Code review of all abort-related changes across 4 user stories
- Files reviewed:
  - `crates/tau-host/src/runtime/executor.rs` — Task struct, abort_task(), take_completed(), prepare_drive()
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort FFI, tau_drive(), drop_plugin_tasks()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, spawn()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration test

### Verdict: REVIEW BLOCKED — 1 fix task required (US-004a: cross-thread abort)
- Learnings for future iterations:
  - Thread-local RUNTIME means ALL FFI functions that modify runtime state only work on the main thread. Any new FFI that needs cross-thread safety must use global queues (WAKE_QUEUE pattern).
  - The borrow discipline (extract → drop borrow → poll → re-borrow) is well-established and correct. Future changes should follow this pattern.
  - WrapperFuture::drop is the bridge between host abort (drops the erased future) and plugin-side TaskCell state (Stage::Aborted). This is load-bearing code.
---

## Iteration 3 - US-REVIEW-PHASE1 (second pass): Review Task Abort (US-001 through US-004a)
- What was done: Re-review after US-004a fix (cross-thread abort via ABORT_QUEUE)
- Files reviewed (all source files in abort scope):
  - `crates/tau-host/src/runtime/executor.rs` — ABORT_QUEUE, queue_abort(), prepare_drive() drain
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort now calls queue_abort()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, TaskCell
  - `crates/tau-rt/src/types.rs` — FfiWaker::into_waker()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin with cross-thread test
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration tests

### Per-task evaluation

**US-001 (FFI abort):** ✅ Clean. `abort_task()` sets aborted+completed, removes from ready_queue, cleans timers. Drop deferred to `take_completed()`.

**US-002 (tau crate wiring):** ✅ Elegant. `JoinHandle<T>` output is `Option<T>` (Some=success, None=abort). `WrapperFuture::drop` detects Running → Aborted transition, wakes JoinHandle. TaskCell ref-counting correct.

**US-003 (tokio shim):** ✅ Clean delegation. `AbortHandle` stores real `task_id`. `JoinSet::abort_all/shutdown/join_next` handle mixed completed/aborted results. `JoinSet::Drop` aborts all (matches tokio).

**US-004 (integration test):** ✅ Covers: abort idle task, abort completed task (no-op), Drop verification, cross-thread abort.

**US-004a (cross-thread abort):** ✅ ABORT_QUEUE pattern matches WAKE_QUEUE exactly. `queue_abort()` pushes + `try_notify_reactor()`. `prepare_drive()` drains. Always returns 1. Clean and consistent.

### Cross-task analysis (all 5 required checks)

1. **Abort during active polling / double-free:** ✅ SAFE. `tau_task_abort` queues to ABORT_QUEUE. Processed in NEXT `prepare_drive()`. During poll phase, the task is never simultaneously aborted+polled. `tasks.remove()` in `take_completed()` returns each task exactly once.

2. **Abort from spawn_blocking (cross-thread):** ✅ WORKS. ABORT_QUEUE is `OnceLock<Mutex<VecDeque<u64>>>` — thread-safe. `try_notify_reactor()` wakes the reactor from any thread. Test verified in abort-test-plugin "cross-thread-abort" command.

3. **plugin_task_count / drop_plugin_tasks:** ✅ CORRECT. `take_plugin_tasks` removes all tasks for a plugin (including aborted ones with completed=true). If aborts are pending in ABORT_QUEUE for already-removed tasks, `abort_task` returns false (task not found) — harmless no-op.

4. **Re-entrancy (aborting from within poll):** ✅ SAFE. `tau_task_abort` doesn't borrow RUNTIME at all — it pushes to a global Mutex queue. No RefCell involved. The abort is processed on the next drive cycle, after all polls complete.

5. **JoinSet::join_next with mixed results:** ✅ CORRECT. Tokio shim `JoinHandle::poll` maps `Some(val)→Ok(val)`, `None→Err(JoinError{cancelled:true})`. `JoinNextFuture` iterates with `swap_remove`. Both completed and aborted handles are handled uniformly.

### Quality assessment
- **Simplicity:** Excellent. Abort flow is straightforward: queue → drain → flag → cleanup → drop → notify JoinHandle. No unnecessary abstractions.
- **Correctness:** All acceptance criteria met. Abort is idempotent. Self-abort safe. Cross-thread safe.
- **Edge cases:** Handled through design (queue-based processing) not if/else patches.
- **Data structures:** ABORT_QUEUE mirrors WAKE_QUEUE — consistent pattern. Task HashMap, VecDeque, BTreeMap all appropriate.
- **Error handling:** Consistent. Abort of non-existent/completed tasks is a no-op.
- **Naming:** Clear and consistent across all layers.
- **Duplication:** Minor: `ffi_waker_to_std` in `tau-rt/src/runtime.rs` duplicates `FfiWaker::into_waker()` in `tau-rt/src/types.rs`. Pre-existing (not introduced by abort tasks). Will be addressed by US-018 (make_ffi_waker utility).

## Phase 1 review PASSED
- Learnings for future iterations:
  - The queue-based abort (ABORT_QUEUE) is strictly better than direct RUNTIME access — simpler, thread-safe, no special cases for self-abort vs cross-thread abort.
  - Two-level "completed" tracking: `Task.completed` (executor-side bool) vs `TaskCell.complete` (plugin-side AtomicBool) — different lifecycles, both correct. Task.completed controls executor scheduling; TaskCell.complete controls JoinHandle result availability.
  - `WrapperFuture::drop` is the critical bridge: host drops the erased future → plugin-side TaskCell transitions to Stage::Aborted → JoinHandle waker notified.
---

## Iteration 2 - US-005: Re-export futures_core::Stream in the tau crate
- What was done:
  - Added `futures-core = "0.3"` to `crates/tau/Cargo.toml`
  - Created `crates/tau/src/stream.rs` with `pub use futures_core::Stream;`
  - Added `pub mod stream;` to `crates/tau/src/lib.rs`
  - All 22 tests pass, build succeeds
- Files changed:
  - `crates/tau/Cargo.toml` — added futures-core dependency
  - `crates/tau/src/stream.rs` — new file, re-exports Stream trait
  - `crates/tau/src/lib.rs` — added pub mod stream
  - `PRD.md` — marked US-005 acceptance criteria complete
- Learnings for future iterations:
  - `tau::stream::Stream` is now available for plugins — same trait as `futures_core::Stream`
  - Future stream work (US-006+) will add FFI handles and combinators to this module
---
## Task self-review PASSED

## Iteration 3 - US-006: StreamHandle — FFI-safe stream with push/poll/close
- What was done:
  - Created `crates/tau-host/src/runtime/streams.rs` — host-side stream registry with `StreamState` (VecDeque<Vec<u8>>, capacity, sender/receiver wakers, closed flags)
  - 7 FFI exports: `tau_stream_create`, `tau_stream_push`, `tau_stream_poll_next`, `tau_stream_free_item`, `tau_stream_close`, `tau_stream_drop`, `tau_stream_poll_flush`
  - Wired `pub mod streams` in `crates/tau-host/src/runtime/mod.rs`
  - Extended `crates/tau/src/stream.rs` with FFI declarations + safe wrappers: `StreamSender` (push/send/close), `StreamReceiver` (impl Stream<Item=Vec<u8>>), `channel()` constructor
  - `PushResult` enum for non-blocking push feedback (Ok/Full/Closed)
  - `SendFuture` for async backpressure (waits via `tau_stream_poll_flush`)
  - Fixed cleanup leak: `tau_stream_close` now removes entry if receiver already dropped
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — new file, host-side stream registry
  - `crates/tau-host/src/runtime/mod.rs` — added `pub mod streams`
  - `crates/tau/src/stream.rs` — FFI declarations + safe wrappers
  - `PRD.md` — marked US-006 acceptance criteria and header complete
- Learnings for future iterations:
  - Stream uses same OnceLock + Mutex + HashMap + u64 handle pattern as events/resources
  - `make_ffi_waker(cx)` pattern: clone waker, box it, put raw ptr in FfiWaker.data, wake_fn unboxes + wakes. Same as tau-tokio/net (will be deduplicated by US-018)
  - Cleanup requires symmetric checks: both `tau_stream_close` (sender) and `tau_stream_drop` (receiver) must check if the other side is done and remove the entry
  - `FfiWaker` data pointer leaks if waker is dropped without being woken — pre-existing design issue, tracked for US-018
  - `tau_stream_free_item` needed for cross-boundary memory ownership — host allocates Box<[u8]>, plugin copies and calls free
---
## Task self-review PASSED

## Iteration 1 - US-006: StreamSender<T>/StreamReceiver<T> — typed FFI streams with inline ring buffer
- What was done:
  - Rewrote `crates/tau-host/src/runtime/streams.rs` — replaced VecDeque<Vec<u8>> with flat ring buffer (`*mut u8` of `capacity × item_size` bytes, properly aligned via std::alloc)
  - StreamState now tracks: buffer ptr, buffer_layout, item_size, capacity, head/tail/count, drop_in_place_fn
  - Ring buffer items are copied via `ptr::copy_nonoverlapping` — zero heap allocation per item
  - `StreamState::drop` calls `drop_in_place_fn` on each remaining occupied slot, then deallocates ring buffer
  - Rewrote `crates/tau/src/stream.rs` — generic `StreamSender<T>` / `StreamReceiver<T>` replacing byte-based types
  - `StreamSender<T>::push()` returns `Result<(), (PushResult, T)>` — returns value on failure
  - `StreamReceiver<T>` implements `Stream<Item = T>` using `MaybeUninit<T>` as the output slot
  - `drop_in_place::<T>` is monomorphized per-T and passed at stream creation
  - Removed `tau_stream_free_item` — no longer needed (items are memcpy'd, not heap-allocated)
  - Changed `tau_stream_create` signature: now takes `item_size`, `item_align`, `drop_in_place_fn`
  - Changed `tau_stream_push` / `tau_stream_poll_next` signatures: work with raw pointers, no data_len
  - ZST support: uses dangling pointer and zero-size layout for item_size == 0
  - Added `unsafe impl Send for StreamState` (buffer ptr only accessed under mutex)
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — complete rewrite to inline ring buffer
  - `crates/tau/src/stream.rs` — complete rewrite to generic typed API
  - `PRD.md` — marked US-006 acceptance criteria and header complete
- Learnings for future iterations:
  - Ring buffer with head/tail/count is simpler than VecDeque for fixed-capacity — no reallocation, predictable memory layout
  - `std::alloc::alloc` with `Layout::from_size_align` is the right way to allocate aligned buffers for arbitrary T
  - StreamSender::push returns the value on failure so it's not lost — good API design for typed channels
  - Pre-existing FfiWaker leak issue (Box<Waker> not dropped when FfiWaker is dropped without being woken) still present — tracked for US-018
---
## Task self-review PASSED

## Iteration 1 - US-REVIEW-PHASE2: Review Stream Core (US-005)
- What was done: Code review of US-005 (re-export futures_core::Stream)
- Files reviewed:
  - `crates/tau/src/stream.rs` — Stream re-export + custom FFI channel infrastructure
  - `crates/tau/src/lib.rs` — `pub mod stream;` export
  - `crates/tau/Cargo.toml` — `futures-core = "0.3"` dependency
  - `crates/tau-host/src/runtime/streams.rs` — host-side StreamState ring buffer registry
  - `crates/tau-host/src/runtime/mod.rs` — `pub mod streams;`

### US-005 evaluation
- ✅ `futures-core = "0.3"` in `crates/tau/Cargo.toml` — correct, minimal semver bound
- ✅ `pub use futures_core::Stream;` — correct re-export, not a custom trait
- ✅ `pub mod stream;` in lib.rs — correct

### ISSUE FOUND: Custom FFI stream channel infrastructure violates PRD design principles
- Commits `8847b5d` (US-006) and `980fe4d` (typed rewrite) added a full custom FFI stream channel system that was NOT part of the current PRD
- Files affected: `crates/tau-host/src/runtime/streams.rs` (host-side), `crates/tau/src/stream.rs` (plugin-side)
- Infrastructure includes: `tau_stream_create`, `tau_stream_push`, `tau_stream_poll_next`, `tau_stream_close`, `tau_stream_drop`, `tau_stream_poll_flush` FFI exports, host-side `StreamState` with inline ring buffer, `StreamSender<T>`/`StreamReceiver<T>` wrappers
- PRD explicitly says: "Channels use standard Rust types — no custom FFI channel infrastructure" and "No custom FFI primitives for things Rust already provides"
- Standard Rust channel crates (`tokio::sync::mpsc` via shim, `async-channel`, `flume`) work across plugins thanks to same-compiler ABI invariant — no FFI needed
- **Action:** Inserted fix task US-005a to remove the custom FFI stream infrastructure

### Verdict: REVIEW BLOCKED — 1 fix task required (US-005a: remove custom FFI stream channels)
- Learnings for future iterations:
  - PRD design principles are load-bearing constraints. "No custom FFI for things Rust already provides" means channel infrastructure should never have been built.
  - The US-006 task was removed from the PRD but its implementation was not reverted. Always check if orphaned code from removed tasks persists.
  - The `tau::stream` module should be minimal: just the `Stream` trait re-export (and later, combinators). Channel creation is NOT its responsibility.
---

## Iteration 2 - US-005a: Remove custom FFI stream channel infrastructure
- What was done:
  - Deleted `crates/tau-host/src/runtime/streams.rs` entirely (host-side StreamState ring buffer, all tau_stream_* FFI exports)
  - Removed `pub mod streams;` from `crates/tau-host/src/runtime/mod.rs`
  - Reverted `crates/tau/src/stream.rs` to minimal 7-line file with only `pub use futures_core::Stream;`
  - Verified no other files reference tau_stream_* or StreamSender/StreamReceiver (only the two removed/reverted files)
  - Build succeeds, all 22 tests pass
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — deleted
  - `crates/tau-host/src/runtime/mod.rs` — removed `pub mod streams;`
  - `crates/tau/src/stream.rs` — reverted to minimal re-export
  - `PRD.md` — marked US-005a complete
- Learnings for future iterations:
  - PRD design principles are enforced: "No custom FFI for things Rust already provides" — standard channel crates work across plugins via same-compiler ABI invariant
  - The `tau::stream` module is now clean and minimal — ready for combinators (US-009+)
---
## Task self-review PASSED

## Iteration 3 - US-REVIEW-PHASE2: Review Stream Core (US-005)
- What was done: Final review pass of US-005 after US-005a cleanup
- Files reviewed:
  - `crates/tau/src/stream.rs` — 7-line file, clean re-export of `futures_core::Stream`
  - `crates/tau/src/lib.rs` — `pub mod stream;` correctly wired
  - `crates/tau/Cargo.toml` — `futures-core = "0.3"` minimal semver bound
- Verification:
  - ✅ `tau::stream::Stream` is `futures_core::Stream` re-export (not custom trait)
  - ✅ No custom FFI channel infrastructure remains (grep for tau_stream_*, StreamSender, StreamReceiver — all clean)
  - ✅ `futures-core` resolves to exactly one version (v0.3.31) across the workspace
  - ✅ Code is minimal and elegant: doc comment + one re-export line
  - ✅ No orphaned host-side code (`streams.rs` deleted, `pub mod streams` removed)

## Phase 2 review PASSED
- Learnings for future iterations:
  - US-005 is now clean after US-005a removed the custom FFI channel code
  - The `tau::stream` module is the right place for future combinator additions (US-009+)
  - Single version of futures-core confirmed — no diamond dependency issues
---

## Iteration 4 - US-009: Synchronous combinators — map, filter, filter_map, take_while
- What was done:
  - Added `pin-project-lite = "0.2"` to `crates/tau/Cargo.toml`
  - Converted `crates/tau/src/stream.rs` to `crates/tau/src/stream/mod.rs` (module directory)
  - Created `crates/tau/src/stream/combinators.rs` with 4 combinator structs: Map, Filter, FilterMap, TakeWhile
  - Created `StreamExt` trait in `mod.rs` with blanket impl for all `Stream + Sized`
  - Each combinator uses `pin_project_lite::pin_project!` for safe pin projections
  - Filter/FilterMap loop to skip non-matching items (canonical pattern from futures-util)
  - TakeWhile has `done: bool` flag for permanent stream termination
  - All combinators provide correct `size_hint` implementations
  - All 22 tests pass, build succeeds
- Files changed:
  - `crates/tau/Cargo.toml` — added pin-project-lite dependency
  - `crates/tau/src/stream.rs` → `crates/tau/src/stream/mod.rs` — converted to module, added StreamExt trait
  - `crates/tau/src/stream/combinators.rs` — new file with Map, Filter, FilterMap, TakeWhile
  - `PRD.md` — marked US-009 acceptance criteria and header complete
- Learnings for future iterations:
  - Sync combinators are much simpler than async ones — no pending_fut/pending_item state needed
  - `pin_project_lite::pin_project!` handles Send auto-derivation correctly — no manual impl needed
  - The `pub(super)` constructor pattern keeps combinator creation gated through StreamExt methods
  - Future async combinators (US-010 `then`) will need `#[pin] pending: Option<Fut>` for in-flight futures
  - `stream/` is now a module directory — future files (e.g., US-010 Then struct) can be added as separate files or in combinators.rs
---
## Task self-review PASSED

## Iteration 5 - US-010: Async combinator — then (async map)
- What was done:
  - Added `Then<St, F, Fut>` combinator struct to `crates/tau/src/stream/combinators.rs`
  - Two-state machine: polls in-flight future first, then polls source stream for next item
  - Newly created futures are polled immediately (avoids unnecessary yield)
  - Added `fn then()` to `StreamExt` trait in `crates/tau/src/stream/mod.rs`
  - Exported `Then` from `crates/tau/src/stream/mod.rs`
  - All 22 tests pass, build succeeds
- Files changed:
  - `crates/tau/src/stream/combinators.rs` — added Then struct + Stream impl
  - `crates/tau/src/stream/mod.rs` — added then() to StreamExt, exported Then
  - `PRD.md` — marked US-010 acceptance criteria and header complete
- Learnings for future iterations:
  - Pin reborrowing: `this.pending.as_mut().as_pin_mut()` is needed after `set()` because `as_pin_mut()` consumes the `Pin<&mut Option<Fut>>`
  - The `then` combinator immediately polls a newly created future — this avoids an unnecessary Pending yield when the future is ready synchronously
  - `size_hint` accounts for in-flight future (+1 when pending is Some)
---
## Task self-review PASSED

## Iteration 6 - US-011: Utility combinators — next, collect, for_each, fold
- What was done:
  - Created `crates/tau/src/stream/consumers.rs` with 4 future structs: Next, Collect, ForEach, Fold
  - Next borrows `&mut St` (requires Unpin), polls stream once per poll
  - Collect/ForEach/Fold take ownership, loop polling until stream exhausted
  - Fold uses `Option<B>` for accumulator to allow ownership transfer through FnMut
  - Added `pub mod consumers` to stream/mod.rs, re-exported all types
  - Added 4 methods to StreamExt trait
  - Build succeeds, all tests pass
- Files changed:
  - `crates/tau/src/stream/consumers.rs` — new file
  - `crates/tau/src/stream/mod.rs` — added consumers module, StreamExt methods
  - `PRD.md` — marked US-011 complete
- Learnings for future iterations:
  - Terminal consumers are futures (not streams) — separate file from combinators is clean separation
  - Fold's accumulator uses Option<B> pattern to move ownership through FnMut without unsafe
  - Collect uses `core::mem::take` to move the Default-able collection out on completion
---
## Task self-review PASSED

## Iteration 7 - US-012: merge — combine two streams into one
- What was done:
  - Added `Merge<A, B>` combinator struct to `crates/tau/src/stream/combinators.rs`
  - Fairness via `poll_a_first: bool` toggle — alternates which stream is polled first each call
  - Extracted `poll_stream()` helper for clean code — polls one stream, updates done flag
  - Completes only when both streams exhausted (a_done && b_done)
  - Added `merge()` method to `StreamExt` trait
  - 5 unit tests: both streams, one empty, both empty, fairness alternation, size_hint
  - All 27 workspace tests pass (25 tau + 2 tau-host)
- Files changed:
  - `crates/tau/src/stream/combinators.rs` — added Merge struct, poll_stream helper, 5 tests
  - `crates/tau/src/stream/mod.rs` — added merge() to StreamExt, exported Merge
  - `PRD.md` — marked US-012 complete
- Learnings for future iterations:
  - Doc comments with em-dash (—) inside `pin_project!` macro cause parse errors — use regular comments instead
  - The `poll_stream` helper pattern is reusable for any combinator that needs to poll multiple sub-streams
  - VecStream test helper with ptr::read + custom Drop is needed for owned item streams in tests
## Task self-review PASSED

## Iteration 8 - US-013: Stream combinator tests
- What was done:
  - Created `crates/tau/src/stream/tests.rs` with 38 comprehensive tests covering all combinators
  - Tests cover: map (3), filter (4), filter_map (4), take_while (5), then (4), next (2), collect (2), for_each (2), fold (4), merge (4), chaining (4)
  - Added `#[cfg(test)] mod tests;` to `crates/tau/src/stream/mod.rs`
  - All 63 tau tests pass (38 new + 25 existing)
  - Tests runnable via `cargo test -p tau`
- Files changed:
  - `crates/tau/src/stream/tests.rs` — new file, comprehensive combinator tests
  - `crates/tau/src/stream/mod.rs` — added test module
  - `PRD.md` — marked US-013 complete
- Learnings for future iterations:
  - Unit tests in tau crate are the right level for combinator testing — no FFI/runtime needed
  - VecStream + noop_waker + collect_sync/poll_once pattern is duplicated from combinators.rs tests but in separate cfg(test) modules — acceptable
  - Combinator chaining tests verify composability across different combinator types
## Task self-review PASSED
---

## Iteration 9 - US-REVIEW-PHASE3: Review Stream Combinators (US-009 through US-013)
- What was done: Code review of all stream combinator and consumer implementations
- Files reviewed:
  - `crates/tau/src/stream/mod.rs` — StreamExt trait with 10 methods, blanket impl
  - `crates/tau/src/stream/combinators.rs` — Map, Filter, FilterMap, TakeWhile, Merge, Then + 5 merge tests
  - `crates/tau/src/stream/consumers.rs` — Next, Collect, ForEach, Fold
  - `crates/tau/src/stream/tests.rs` — 38 comprehensive tests

### Per-task evaluation

**US-009 (sync combinators: map, filter, filter_map, take_while):** ✅ Clean canonical implementations. Pin projections via `pin_project_lite` — sound by construction. Filter/FilterMap loop correctly. TakeWhile `done` flag is permanent. size_hint correct everywhere.

**US-010 (async combinator: then):** ✅ Two-state machine (pending future vs poll source). Immediately polls newly created future to avoid unnecessary yield. Inner future dropped cleanly when Then is dropped (pin_project handles it). size_hint adds +1 when future in-flight.

**US-011 (consumers: next, collect, for_each, fold):** ✅ Clean separation into consumers.rs (futures, not streams). Next borrows (&mut St, requires Unpin). Collect/ForEach/Fold loop to exhaustion. Fold uses Option<B> pattern for ownership transfer through FnMut — elegant.

**US-012 (merge):** ✅ Fairness via `poll_a_first` toggle. `poll_stream` helper keeps code DRY. Both-done check correct. size_hint sums both streams with saturating arithmetic.

**US-013 (tests):** ✅ 38 tests covering all combinators + 4 chaining tests. Good coverage of edge cases (empty streams, all-pass, all-fail, type changes).

### Cross-task analysis (5 required checks)

1. **Pin projection safety:** ✅ All 9 structs use `pin_project_lite::pin_project!`. No manual `get_unchecked_mut` anywhere.

2. **Then inner future dropped mid-execution:** ✅ `pin_project!` generates proper Drop. Option<Fut> is dropped cleanly — no dangling state.

3. **Merge fairness:** ✅ `poll_a_first` alternates each call. Neither side starves. Test verifies [1,2,1,2,1,2] alternation.

4. **None (stream termination) propagation:** ✅ All combinators forward Ready(None). TakeWhile sets done→true then None. Merge needs both done. Consumers loop until None.

5. **StreamExt naming conflicts with futures::StreamExt:** ✅ Method names match ecosystem conventions exactly. If both traits in scope, Rust's standard disambiguation applies — not a bug.

### Minor observation (not a fix task)
- Test helpers (VecStream, noop_waker, collect_sync) duplicated between combinators.rs tests and tests.rs — both are #[cfg(test)] in separate modules. Acceptable for test code; not worth a fix task.

## Phase 3 review PASSED
- Learnings for future iterations:
  - pin_project_lite provides sound pin projections with zero boilerplate — correct tool choice
  - The sync/async combinator split (FnMut vs FnMut→Fut) is clean and mirrors futures-util
  - consumers.rs (futures) vs combinators.rs (streams) is a good organizational pattern
  - Merge's poll_stream helper is reusable for future N-way merge if needed
---

## Iteration 10 - US-014: Verify real tokio-stream compiles against our tokio shim
- What was done:
  - Researched tokio-stream's tokio dependency: unconditionally requires `sync`, default feature `time`
  - Added 6 missing methods to tau-tokio's mpsc module:
    - `Receiver::len()`, `is_empty()`, `is_closed()`, `capacity()`, `max_capacity()`
    - `UnboundedReceiver::len()`, `is_empty()`, `is_closed()`
  - Added `watch::error` sub-module with re-exports (for WatchStream compatibility)
  - Created `plugins/stream-test-plugin/` with tokio-stream 0.1 dependency (default features)
  - Plugin uses `ReceiverStream::new(rx)`, `.map()`, `.filter()`, `.next()` from tokio_stream::StreamExt
  - Documented full feature compatibility table in plugin doc comment
  - tokio-stream v0.1.18 compiles successfully against tau-tokio shim
  - All 65 workspace tests pass, cargo build succeeds
- Files changed:
  - `crates/tau-tokio/src/sync/mpsc.rs` — added len/is_empty/is_closed/capacity/max_capacity methods
  - `crates/tau-tokio/src/sync/watch.rs` — added `pub mod error` re-export
  - `plugins/stream-test-plugin/Cargo.toml` — new test plugin
  - `plugins/stream-test-plugin/src/lib.rs` — new test plugin source
  - `PRD.md` — marked US-014 complete
- Learnings for future iterations:
  - tokio-stream with default features only needs `sync` + `time` from tokio — our shim covers both
  - Missing methods were trivial one-liners (len, capacity, etc.) — the real challenge was knowing which methods tokio-stream calls
  - Optional features (net, signal, io-util, fs, sync) need more substantial APIs we don't have yet
  - The `define_plugin!` macro requires init/destroy/request in that exact order
  - Plugin spawned tasks may not run to completion if the host shuts down immediately — this is expected behavior
## Task self-review PASSED
---

## Iteration 11 - US-COMP-001: Restructure build cache with environment hash
- What was done:
  - Verified existing implementation of two-level build cache in compiler.rs
  - Added `env_hash: OnceCell<String>` field to `Compiler` struct
  - Added `get_or_compute_env_hash()` method that hashes: HOST_VERSION, HOST_RUSTFLAGS, HOST_PANIC, HOST_TARGET_FEATURES, tau-rt dylib content, PATCHES_LIST
  - Added `parse_crate_name()` to extract package name from plugin Cargo.toml
  - Restructured `get_build_cache_dir()` to return `~/.tau/buildcache/<env_hash>/<crate_name>.<src_hash>/`
  - Verified with dist build: cache dir is `afff4643e5ad47f/example-plugin.43ac1298/`
  - All 65 tests pass, dist build and plugin run work correctly
- Files changed:
  - `crates/tau-host/src/compiler.rs` — env_hash field, get_or_compute_env_hash(), parse_crate_name(), restructured get_build_cache_dir()
  - `PRD.md` — marked US-COMP-001 acceptance criteria and header complete
- Learnings for future iterations:
  - OnceCell is the right pattern for lazy-computed cached values on non-Send structs
  - DefaultHasher (SipHash) is adequate for cache keys — not cryptographic but collision-resistant enough
  - parse_crate_name is a simple line-by-line search — works for all current plugins but wouldn't handle exotic Cargo.toml layouts
---
## Task self-review PASSED

## Iteration 2 - US-COMP-002: Dep-file fast path — skip cargo when sources unchanged
- What was done:
  - Added `check_up_to_date()` method to `Compiler` that parses cargo dep files and checks mtimes
  - Added `parse_dep_file()` for Makefile-format dep file parsing (handles escaped spaces, continuation lines)
  - Wired fast path into `compile_plugin()` — calls `check_up_to_date()` before any cargo setup
  - Also checks `Cargo.toml` mtime (catches dependency changes not listed in dep file)
  - Added 5 unit tests for dep-file parser (simple, continuation, escaped spaces, empty, no colon)
  - All 70 tests pass (63 tau + 7 tau-host), build succeeds
  - Manual verification: both runs show "Plugin up-to-date (skipped)", second run 0.186s total
- Files changed:
  - `crates/tau-host/src/compiler.rs` — check_up_to_date(), parse_dep_file(), fast path in compile_plugin(), 5 tests
  - `PRD.md` — marked US-COMP-002 acceptance criteria and header complete
- Learnings for future iterations:
  - Cargo dep files are at `target/<profile>/lib<crate>.d` in Makefile format: `<output>: <dep1> <dep2> ...`
  - Dep files list all transitive source files (plugin + patched crates) but NOT dylib dependencies — those are handled by the environment hash
  - The fast path gracefully degrades: any failure (missing files, parse errors, stat errors) falls through to cargo
  - Escaped spaces in paths (`\ `) must be handled for paths with spaces
---
## Task self-review PASSED

## Iteration 3 - US-015: Verify futures-core resolves correctly in plugin builds
- What was done:
  - Created `plugins/http-plugin/` — minimal plugin depending on `reqwest` (pulls in hyper → http-body → futures-core)
  - Created `plugins/kube-plugin/` — minimal plugin depending on `kube` with runtime feature (pulls in kube-runtime → futures-core via many paths)
  - Both plugins include compile-time assertions proving `tau::stream::Stream == futures_core::Stream` (same trait, not duplicates)
  - Added `Instant` newtype wrapper to `crates/tau-tokio/src/time/mod.rs` with `into_std()`/`from_std()` methods — required by `kube-runtime`'s `backoff_reset_timer` module
  - Verified: exactly ONE `futures-core` rlib (`e554339327a5ca28`) in build cache for both plugins
  - `tau/Cargo.toml` already has `futures-core = "0.3"` (minimal semver bound) — no relaxation needed
  - All 70 workspace tests pass, both plugins compile and load through dist
- Files changed:
  - `plugins/http-plugin/Cargo.toml`, `plugins/http-plugin/src/lib.rs` — new http-plugin
  - `plugins/kube-plugin/Cargo.toml`, `plugins/kube-plugin/src/lib.rs` — new kube-plugin
  - `crates/tau-tokio/src/time/mod.rs` — Instant newtype with into_std/from_std + operator impls
  - `PRD.md` — marked US-015 acceptance criteria and header complete
- Learnings for future iterations:
  - Our tokio shim previously re-exported `std::time::Instant` directly. Real tokio wraps it in a newtype with `into_std()/from_std()`. Ecosystem crates (kube-runtime) depend on these methods.
  - The Instant newtype needs full operator coverage: Add/Sub Duration, Sub Instant→Duration, AddAssign, SubAssign, From conversions
  - `k8s-openapi` requires explicit version feature (`latest`) — version must match kube's expected k8s-openapi version
  - Compile-time trait equality assertions (`fn _check<T: TraitA + TraitB>() {}`) are the best way to prove two traits are the same — fails at compile time if they're different
---
## Task self-review PASSED
