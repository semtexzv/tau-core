# Progress Log

## Learnings
(Patterns discovered during implementation)
- `tau` crate re-exports everything from `tau-rt` via `pub use tau_rt::*`. The actual runtime code lives in `crates/tau-rt/src/runtime.rs`, not `crates/tau/src/runtime.rs` (which doesn't exist).
- `JoinHandle<T>` output is `Option<T>` at the tau level — `Some(val)` for success, `None` for abort. The tokio shim converts `None` → `Err(JoinError { cancelled: true })`.
- Guard tests in `crates/tau/src/guard.rs` use a shared `static UNLOADED: AtomicBool` that causes flaky failures when tests run in parallel. Use `--test-threads=1` for reliable full suite runs.

---

## Iteration 1 - US-002: Wire abort through tau crate and JoinHandle
- What was done:
  - Added `tau_task_abort` FFI declaration to `crates/tau-rt/src/runtime.rs` extern block
  - Added `Stage::Aborted` variant to the `Stage<T>` enum
  - Implemented `JoinHandle::abort()` to call `tau_task_abort(self.task_id)`
  - Updated `WrapperFuture::drop` to detect abort (stage still Running) and mark TaskCell as `Stage::Aborted`, set complete flag, wake JoinHandle waker
  - Changed `JoinHandle` output from `T` to `Option<T>` — `Some(val)` for success, `None` for abort
  - Updated `try_read_output` vtable function to handle `Stage::Aborted` → `Poll::Ready(None)`
  - Updated `block_on` to handle `Option<T>` return
  - Updated tokio shim `JoinHandle` to convert `None` → `Err(JoinError { cancelled: true })`
  - Added `cancelled: bool` field to `JoinError`
- Files changed:
  - `crates/tau-rt/src/runtime.rs` — core abort wiring
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle/JoinError updates
  - `PRD.md` — marked acceptance criteria
- Learnings for future iterations:
  - The `WrapperFuture::drop` is the key integration point — when the host executor drops the future (after abort), this is where the TaskCell gets marked as aborted and the JoinHandle waker is notified
  - `is_finished()` automatically works for aborted tasks because the `complete` AtomicBool is set in `WrapperFuture::drop`
  - US-003 needs to wire `AbortHandle` with a real `task_id` instead of the current phantom marker
---

## Task self-review PASSED

## Iteration 1 - US-004: Abort integration test
- What was done:
  - Created abort-test-plugin with spawn/abort/check/spawn-and-complete/abort-completed commands
  - Created test-abort.sh and test-abort.txt with 8 assertions covering:
    - Abort idle sleeping task → future dropped, DropDetector runs, is_finished=1
    - Abort already-completed task → no-op (found=0)
  - Fixed critical RefCell re-entrancy bug: cleanup_completed → take_completed (extract tasks, drop outside borrow)
  - Same fix applied to drop_plugin_tasks → take_plugin_tasks
  - Made Task struct pub(crate) for cross-module access
  - Added 'drive' command to test mode for polling background tasks without block_on
- Files changed:
  - plugins/abort-test-plugin/src/lib.rs — rewrote with statics, proper return values
  - tests/test-abort.sh — updated assertions
  - tests/test-abort.txt — added drive commands, fixed flow
  - crates/tau-host/src/runtime/executor.rs — take_completed, take_plugin_tasks, Task pub(crate)
  - crates/tau-host/src/runtime/mod.rs — drop tasks outside borrow
  - crates/tau-host/src/main.rs — added 'drive' test command
  - PRD.md — marked US-004 acceptance criteria
- Learnings for future iterations:
  - Request handler return value is passed to block_on(). Return 0 for fire-and-forget spawns.
  - RefCell re-entrancy is a recurring pattern: Task::drop → SleepFuture::drop → tau_timer_cancel → borrow_mut. Always extract tasks before dropping.
  - The 'drive' test command is needed to poll background tasks that aren't waited on.
  - JoinHandle can't be stored in tau::resource (requires Clone). Use statics or raw task_id + FFI.
---
## Task self-review PASSED

## Iteration 2 - US-REVIEW-PHASE1 (first pass): Review Task Abort (US-001 through US-004)
- What was done: Code review of all abort-related changes across 4 user stories
- Files reviewed:
  - `crates/tau-host/src/runtime/executor.rs` — Task struct, abort_task(), take_completed(), prepare_drive()
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort FFI, tau_drive(), drop_plugin_tasks()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, spawn()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration test

### Verdict: REVIEW BLOCKED — 1 fix task required (US-004a: cross-thread abort)
- Learnings for future iterations:
  - Thread-local RUNTIME means ALL FFI functions that modify runtime state only work on the main thread. Any new FFI that needs cross-thread safety must use global queues (WAKE_QUEUE pattern).
  - The borrow discipline (extract → drop borrow → poll → re-borrow) is well-established and correct. Future changes should follow this pattern.
  - WrapperFuture::drop is the bridge between host abort (drops the erased future) and plugin-side TaskCell state (Stage::Aborted). This is load-bearing code.
---

## Iteration 3 - US-REVIEW-PHASE1 (second pass): Review Task Abort (US-001 through US-004a)
- What was done: Re-review after US-004a fix (cross-thread abort via ABORT_QUEUE)
- Files reviewed (all source files in abort scope):
  - `crates/tau-host/src/runtime/executor.rs` — ABORT_QUEUE, queue_abort(), prepare_drive() drain
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort now calls queue_abort()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, TaskCell
  - `crates/tau-rt/src/types.rs` — FfiWaker::into_waker()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin with cross-thread test
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration tests

### Per-task evaluation

**US-001 (FFI abort):** ✅ Clean. `abort_task()` sets aborted+completed, removes from ready_queue, cleans timers. Drop deferred to `take_completed()`.

**US-002 (tau crate wiring):** ✅ Elegant. `JoinHandle<T>` output is `Option<T>` (Some=success, None=abort). `WrapperFuture::drop` detects Running → Aborted transition, wakes JoinHandle. TaskCell ref-counting correct.

**US-003 (tokio shim):** ✅ Clean delegation. `AbortHandle` stores real `task_id`. `JoinSet::abort_all/shutdown/join_next` handle mixed completed/aborted results. `JoinSet::Drop` aborts all (matches tokio).

**US-004 (integration test):** ✅ Covers: abort idle task, abort completed task (no-op), Drop verification, cross-thread abort.

**US-004a (cross-thread abort):** ✅ ABORT_QUEUE pattern matches WAKE_QUEUE exactly. `queue_abort()` pushes + `try_notify_reactor()`. `prepare_drive()` drains. Always returns 1. Clean and consistent.

### Cross-task analysis (all 5 required checks)

1. **Abort during active polling / double-free:** ✅ SAFE. `tau_task_abort` queues to ABORT_QUEUE. Processed in NEXT `prepare_drive()`. During poll phase, the task is never simultaneously aborted+polled. `tasks.remove()` in `take_completed()` returns each task exactly once.

2. **Abort from spawn_blocking (cross-thread):** ✅ WORKS. ABORT_QUEUE is `OnceLock<Mutex<VecDeque<u64>>>` — thread-safe. `try_notify_reactor()` wakes the reactor from any thread. Test verified in abort-test-plugin "cross-thread-abort" command.

3. **plugin_task_count / drop_plugin_tasks:** ✅ CORRECT. `take_plugin_tasks` removes all tasks for a plugin (including aborted ones with completed=true). If aborts are pending in ABORT_QUEUE for already-removed tasks, `abort_task` returns false (task not found) — harmless no-op.

4. **Re-entrancy (aborting from within poll):** ✅ SAFE. `tau_task_abort` doesn't borrow RUNTIME at all — it pushes to a global Mutex queue. No RefCell involved. The abort is processed on the next drive cycle, after all polls complete.

5. **JoinSet::join_next with mixed results:** ✅ CORRECT. Tokio shim `JoinHandle::poll` maps `Some(val)→Ok(val)`, `None→Err(JoinError{cancelled:true})`. `JoinNextFuture` iterates with `swap_remove`. Both completed and aborted handles are handled uniformly.

### Quality assessment
- **Simplicity:** Excellent. Abort flow is straightforward: queue → drain → flag → cleanup → drop → notify JoinHandle. No unnecessary abstractions.
- **Correctness:** All acceptance criteria met. Abort is idempotent. Self-abort safe. Cross-thread safe.
- **Edge cases:** Handled through design (queue-based processing) not if/else patches.
- **Data structures:** ABORT_QUEUE mirrors WAKE_QUEUE — consistent pattern. Task HashMap, VecDeque, BTreeMap all appropriate.
- **Error handling:** Consistent. Abort of non-existent/completed tasks is a no-op.
- **Naming:** Clear and consistent across all layers.
- **Duplication:** Minor: `ffi_waker_to_std` in `tau-rt/src/runtime.rs` duplicates `FfiWaker::into_waker()` in `tau-rt/src/types.rs`. Pre-existing (not introduced by abort tasks). Will be addressed by US-018 (make_ffi_waker utility).

## Phase 1 review PASSED
- Learnings for future iterations:
  - The queue-based abort (ABORT_QUEUE) is strictly better than direct RUNTIME access — simpler, thread-safe, no special cases for self-abort vs cross-thread abort.
  - Two-level "completed" tracking: `Task.completed` (executor-side bool) vs `TaskCell.complete` (plugin-side AtomicBool) — different lifecycles, both correct. Task.completed controls executor scheduling; TaskCell.complete controls JoinHandle result availability.
  - `WrapperFuture::drop` is the critical bridge: host drops the erased future → plugin-side TaskCell transitions to Stage::Aborted → JoinHandle waker notified.
---

## Iteration 2 - US-005: Re-export futures_core::Stream in the tau crate
- What was done:
  - Added `futures-core = "0.3"` to `crates/tau/Cargo.toml`
  - Created `crates/tau/src/stream.rs` with `pub use futures_core::Stream;`
  - Added `pub mod stream;` to `crates/tau/src/lib.rs`
  - All 22 tests pass, build succeeds
- Files changed:
  - `crates/tau/Cargo.toml` — added futures-core dependency
  - `crates/tau/src/stream.rs` — new file, re-exports Stream trait
  - `crates/tau/src/lib.rs` — added pub mod stream
  - `PRD.md` — marked US-005 acceptance criteria complete
- Learnings for future iterations:
  - `tau::stream::Stream` is now available for plugins — same trait as `futures_core::Stream`
  - Future stream work (US-006+) will add FFI handles and combinators to this module
---
## Task self-review PASSED

## Iteration 3 - US-006: StreamHandle — FFI-safe stream with push/poll/close
- What was done:
  - Created `crates/tau-host/src/runtime/streams.rs` — host-side stream registry with `StreamState` (VecDeque<Vec<u8>>, capacity, sender/receiver wakers, closed flags)
  - 7 FFI exports: `tau_stream_create`, `tau_stream_push`, `tau_stream_poll_next`, `tau_stream_free_item`, `tau_stream_close`, `tau_stream_drop`, `tau_stream_poll_flush`
  - Wired `pub mod streams` in `crates/tau-host/src/runtime/mod.rs`
  - Extended `crates/tau/src/stream.rs` with FFI declarations + safe wrappers: `StreamSender` (push/send/close), `StreamReceiver` (impl Stream<Item=Vec<u8>>), `channel()` constructor
  - `PushResult` enum for non-blocking push feedback (Ok/Full/Closed)
  - `SendFuture` for async backpressure (waits via `tau_stream_poll_flush`)
  - Fixed cleanup leak: `tau_stream_close` now removes entry if receiver already dropped
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — new file, host-side stream registry
  - `crates/tau-host/src/runtime/mod.rs` — added `pub mod streams`
  - `crates/tau/src/stream.rs` — FFI declarations + safe wrappers
  - `PRD.md` — marked US-006 acceptance criteria and header complete
- Learnings for future iterations:
  - Stream uses same OnceLock + Mutex + HashMap + u64 handle pattern as events/resources
  - `make_ffi_waker(cx)` pattern: clone waker, box it, put raw ptr in FfiWaker.data, wake_fn unboxes + wakes. Same as tau-tokio/net (will be deduplicated by US-018)
  - Cleanup requires symmetric checks: both `tau_stream_close` (sender) and `tau_stream_drop` (receiver) must check if the other side is done and remove the entry
  - `FfiWaker` data pointer leaks if waker is dropped without being woken — pre-existing design issue, tracked for US-018
  - `tau_stream_free_item` needed for cross-boundary memory ownership — host allocates Box<[u8]>, plugin copies and calls free
---
## Task self-review PASSED

## Iteration 1 - US-006: StreamSender<T>/StreamReceiver<T> — typed FFI streams with inline ring buffer
- What was done:
  - Rewrote `crates/tau-host/src/runtime/streams.rs` — replaced VecDeque<Vec<u8>> with flat ring buffer (`*mut u8` of `capacity × item_size` bytes, properly aligned via std::alloc)
  - StreamState now tracks: buffer ptr, buffer_layout, item_size, capacity, head/tail/count, drop_in_place_fn
  - Ring buffer items are copied via `ptr::copy_nonoverlapping` — zero heap allocation per item
  - `StreamState::drop` calls `drop_in_place_fn` on each remaining occupied slot, then deallocates ring buffer
  - Rewrote `crates/tau/src/stream.rs` — generic `StreamSender<T>` / `StreamReceiver<T>` replacing byte-based types
  - `StreamSender<T>::push()` returns `Result<(), (PushResult, T)>` — returns value on failure
  - `StreamReceiver<T>` implements `Stream<Item = T>` using `MaybeUninit<T>` as the output slot
  - `drop_in_place::<T>` is monomorphized per-T and passed at stream creation
  - Removed `tau_stream_free_item` — no longer needed (items are memcpy'd, not heap-allocated)
  - Changed `tau_stream_create` signature: now takes `item_size`, `item_align`, `drop_in_place_fn`
  - Changed `tau_stream_push` / `tau_stream_poll_next` signatures: work with raw pointers, no data_len
  - ZST support: uses dangling pointer and zero-size layout for item_size == 0
  - Added `unsafe impl Send for StreamState` (buffer ptr only accessed under mutex)
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — complete rewrite to inline ring buffer
  - `crates/tau/src/stream.rs` — complete rewrite to generic typed API
  - `PRD.md` — marked US-006 acceptance criteria and header complete
- Learnings for future iterations:
  - Ring buffer with head/tail/count is simpler than VecDeque for fixed-capacity — no reallocation, predictable memory layout
  - `std::alloc::alloc` with `Layout::from_size_align` is the right way to allocate aligned buffers for arbitrary T
  - StreamSender::push returns the value on failure so it's not lost — good API design for typed channels
  - Pre-existing FfiWaker leak issue (Box<Waker> not dropped when FfiWaker is dropped without being woken) still present — tracked for US-018
---
## Task self-review PASSED

## Iteration 1 - US-REVIEW-PHASE2: Review Stream Core (US-005)
- What was done: Code review of US-005 (re-export futures_core::Stream)
- Files reviewed:
  - `crates/tau/src/stream.rs` — Stream re-export + custom FFI channel infrastructure
  - `crates/tau/src/lib.rs` — `pub mod stream;` export
  - `crates/tau/Cargo.toml` — `futures-core = "0.3"` dependency
  - `crates/tau-host/src/runtime/streams.rs` — host-side StreamState ring buffer registry
  - `crates/tau-host/src/runtime/mod.rs` — `pub mod streams;`

### US-005 evaluation
- ✅ `futures-core = "0.3"` in `crates/tau/Cargo.toml` — correct, minimal semver bound
- ✅ `pub use futures_core::Stream;` — correct re-export, not a custom trait
- ✅ `pub mod stream;` in lib.rs — correct

### ISSUE FOUND: Custom FFI stream channel infrastructure violates PRD design principles
- Commits `8847b5d` (US-006) and `980fe4d` (typed rewrite) added a full custom FFI stream channel system that was NOT part of the current PRD
- Files affected: `crates/tau-host/src/runtime/streams.rs` (host-side), `crates/tau/src/stream.rs` (plugin-side)
- Infrastructure includes: `tau_stream_create`, `tau_stream_push`, `tau_stream_poll_next`, `tau_stream_close`, `tau_stream_drop`, `tau_stream_poll_flush` FFI exports, host-side `StreamState` with inline ring buffer, `StreamSender<T>`/`StreamReceiver<T>` wrappers
- PRD explicitly says: "Channels use standard Rust types — no custom FFI channel infrastructure" and "No custom FFI primitives for things Rust already provides"
- Standard Rust channel crates (`tokio::sync::mpsc` via shim, `async-channel`, `flume`) work across plugins thanks to same-compiler ABI invariant — no FFI needed
- **Action:** Inserted fix task US-005a to remove the custom FFI stream infrastructure

### Verdict: REVIEW BLOCKED — 1 fix task required (US-005a: remove custom FFI stream channels)
- Learnings for future iterations:
  - PRD design principles are load-bearing constraints. "No custom FFI for things Rust already provides" means channel infrastructure should never have been built.
  - The US-006 task was removed from the PRD but its implementation was not reverted. Always check if orphaned code from removed tasks persists.
  - The `tau::stream` module should be minimal: just the `Stream` trait re-export (and later, combinators). Channel creation is NOT its responsibility.
---

## Iteration 2 - US-005a: Remove custom FFI stream channel infrastructure
- What was done:
  - Deleted `crates/tau-host/src/runtime/streams.rs` entirely (host-side StreamState ring buffer, all tau_stream_* FFI exports)
  - Removed `pub mod streams;` from `crates/tau-host/src/runtime/mod.rs`
  - Reverted `crates/tau/src/stream.rs` to minimal 7-line file with only `pub use futures_core::Stream;`
  - Verified no other files reference tau_stream_* or StreamSender/StreamReceiver (only the two removed/reverted files)
  - Build succeeds, all 22 tests pass
- Files changed:
  - `crates/tau-host/src/runtime/streams.rs` — deleted
  - `crates/tau-host/src/runtime/mod.rs` — removed `pub mod streams;`
  - `crates/tau/src/stream.rs` — reverted to minimal re-export
  - `PRD.md` — marked US-005a complete
- Learnings for future iterations:
  - PRD design principles are enforced: "No custom FFI for things Rust already provides" — standard channel crates work across plugins via same-compiler ABI invariant
  - The `tau::stream` module is now clean and minimal — ready for combinators (US-009+)
---
## Task self-review PASSED

## Iteration 3 - US-REVIEW-PHASE2: Review Stream Core (US-005)
- What was done: Final review pass of US-005 after US-005a cleanup
- Files reviewed:
  - `crates/tau/src/stream.rs` — 7-line file, clean re-export of `futures_core::Stream`
  - `crates/tau/src/lib.rs` — `pub mod stream;` correctly wired
  - `crates/tau/Cargo.toml` — `futures-core = "0.3"` minimal semver bound
- Verification:
  - ✅ `tau::stream::Stream` is `futures_core::Stream` re-export (not custom trait)
  - ✅ No custom FFI channel infrastructure remains (grep for tau_stream_*, StreamSender, StreamReceiver — all clean)
  - ✅ `futures-core` resolves to exactly one version (v0.3.31) across the workspace
  - ✅ Code is minimal and elegant: doc comment + one re-export line
  - ✅ No orphaned host-side code (`streams.rs` deleted, `pub mod streams` removed)

## Phase 2 review PASSED
- Learnings for future iterations:
  - US-005 is now clean after US-005a removed the custom FFI channel code
  - The `tau::stream` module is the right place for future combinator additions (US-009+)
  - Single version of futures-core confirmed — no diamond dependency issues
---

## Iteration 4 - US-009: Synchronous combinators — map, filter, filter_map, take_while
- What was done:
  - Added `pin-project-lite = "0.2"` to `crates/tau/Cargo.toml`
  - Converted `crates/tau/src/stream.rs` to `crates/tau/src/stream/mod.rs` (module directory)
  - Created `crates/tau/src/stream/combinators.rs` with 4 combinator structs: Map, Filter, FilterMap, TakeWhile
  - Created `StreamExt` trait in `mod.rs` with blanket impl for all `Stream + Sized`
  - Each combinator uses `pin_project_lite::pin_project!` for safe pin projections
  - Filter/FilterMap loop to skip non-matching items (canonical pattern from futures-util)
  - TakeWhile has `done: bool` flag for permanent stream termination
  - All combinators provide correct `size_hint` implementations
  - All 22 tests pass, build succeeds
- Files changed:
  - `crates/tau/Cargo.toml` — added pin-project-lite dependency
  - `crates/tau/src/stream.rs` → `crates/tau/src/stream/mod.rs` — converted to module, added StreamExt trait
  - `crates/tau/src/stream/combinators.rs` — new file with Map, Filter, FilterMap, TakeWhile
  - `PRD.md` — marked US-009 acceptance criteria and header complete
- Learnings for future iterations:
  - Sync combinators are much simpler than async ones — no pending_fut/pending_item state needed
  - `pin_project_lite::pin_project!` handles Send auto-derivation correctly — no manual impl needed
  - The `pub(super)` constructor pattern keeps combinator creation gated through StreamExt methods
  - Future async combinators (US-010 `then`) will need `#[pin] pending: Option<Fut>` for in-flight futures
  - `stream/` is now a module directory — future files (e.g., US-010 Then struct) can be added as separate files or in combinators.rs
---
## Task self-review PASSED
