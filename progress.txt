# Progress Log

## Learnings
(Patterns discovered during implementation)
- `tau` crate re-exports everything from `tau-rt` via `pub use tau_rt::*`. The actual runtime code lives in `crates/tau-rt/src/runtime.rs`, not `crates/tau/src/runtime.rs` (which doesn't exist).
- `JoinHandle<T>` output is `Option<T>` at the tau level — `Some(val)` for success, `None` for abort. The tokio shim converts `None` → `Err(JoinError { cancelled: true })`.
- Guard tests in `crates/tau/src/guard.rs` use a shared `static UNLOADED: AtomicBool` that causes flaky failures when tests run in parallel. Use `--test-threads=1` for reliable full suite runs.

---

## Iteration 1 - US-002: Wire abort through tau crate and JoinHandle
- What was done:
  - Added `tau_task_abort` FFI declaration to `crates/tau-rt/src/runtime.rs` extern block
  - Added `Stage::Aborted` variant to the `Stage<T>` enum
  - Implemented `JoinHandle::abort()` to call `tau_task_abort(self.task_id)`
  - Updated `WrapperFuture::drop` to detect abort (stage still Running) and mark TaskCell as `Stage::Aborted`, set complete flag, wake JoinHandle waker
  - Changed `JoinHandle` output from `T` to `Option<T>` — `Some(val)` for success, `None` for abort
  - Updated `try_read_output` vtable function to handle `Stage::Aborted` → `Poll::Ready(None)`
  - Updated `block_on` to handle `Option<T>` return
  - Updated tokio shim `JoinHandle` to convert `None` → `Err(JoinError { cancelled: true })`
  - Added `cancelled: bool` field to `JoinError`
- Files changed:
  - `crates/tau-rt/src/runtime.rs` — core abort wiring
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle/JoinError updates
  - `PRD.md` — marked acceptance criteria
- Learnings for future iterations:
  - The `WrapperFuture::drop` is the key integration point — when the host executor drops the future (after abort), this is where the TaskCell gets marked as aborted and the JoinHandle waker is notified
  - `is_finished()` automatically works for aborted tasks because the `complete` AtomicBool is set in `WrapperFuture::drop`
  - US-003 needs to wire `AbortHandle` with a real `task_id` instead of the current phantom marker
---

## Task self-review PASSED

## Iteration 1 - US-004: Abort integration test
- What was done:
  - Created abort-test-plugin with spawn/abort/check/spawn-and-complete/abort-completed commands
  - Created test-abort.sh and test-abort.txt with 8 assertions covering:
    - Abort idle sleeping task → future dropped, DropDetector runs, is_finished=1
    - Abort already-completed task → no-op (found=0)
  - Fixed critical RefCell re-entrancy bug: cleanup_completed → take_completed (extract tasks, drop outside borrow)
  - Same fix applied to drop_plugin_tasks → take_plugin_tasks
  - Made Task struct pub(crate) for cross-module access
  - Added 'drive' command to test mode for polling background tasks without block_on
- Files changed:
  - plugins/abort-test-plugin/src/lib.rs — rewrote with statics, proper return values
  - tests/test-abort.sh — updated assertions
  - tests/test-abort.txt — added drive commands, fixed flow
  - crates/tau-host/src/runtime/executor.rs — take_completed, take_plugin_tasks, Task pub(crate)
  - crates/tau-host/src/runtime/mod.rs — drop tasks outside borrow
  - crates/tau-host/src/main.rs — added 'drive' test command
  - PRD.md — marked US-004 acceptance criteria
- Learnings for future iterations:
  - Request handler return value is passed to block_on(). Return 0 for fire-and-forget spawns.
  - RefCell re-entrancy is a recurring pattern: Task::drop → SleepFuture::drop → tau_timer_cancel → borrow_mut. Always extract tasks before dropping.
  - The 'drive' test command is needed to poll background tasks that aren't waited on.
  - JoinHandle can't be stored in tau::resource (requires Clone). Use statics or raw task_id + FFI.
---
## Task self-review PASSED

## Iteration 2 - US-REVIEW-PHASE1 (first pass): Review Task Abort (US-001 through US-004)
- What was done: Code review of all abort-related changes across 4 user stories
- Files reviewed:
  - `crates/tau-host/src/runtime/executor.rs` — Task struct, abort_task(), take_completed(), prepare_drive()
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort FFI, tau_drive(), drop_plugin_tasks()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, spawn()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration test

### Verdict: REVIEW BLOCKED — 1 fix task required (US-004a: cross-thread abort)
- Learnings for future iterations:
  - Thread-local RUNTIME means ALL FFI functions that modify runtime state only work on the main thread. Any new FFI that needs cross-thread safety must use global queues (WAKE_QUEUE pattern).
  - The borrow discipline (extract → drop borrow → poll → re-borrow) is well-established and correct. Future changes should follow this pattern.
  - WrapperFuture::drop is the bridge between host abort (drops the erased future) and plugin-side TaskCell state (Stage::Aborted). This is load-bearing code.
---

## Iteration 3 - US-REVIEW-PHASE1 (second pass): Review Task Abort (US-001 through US-004a)
- What was done: Re-review after US-004a fix (cross-thread abort via ABORT_QUEUE)
- Files reviewed (all source files in abort scope):
  - `crates/tau-host/src/runtime/executor.rs` — ABORT_QUEUE, queue_abort(), prepare_drive() drain
  - `crates/tau-host/src/runtime/mod.rs` — tau_task_abort now calls queue_abort()
  - `crates/tau-rt/src/runtime.rs` — Stage::Aborted, WrapperFuture::drop, JoinHandle, TaskCell
  - `crates/tau-rt/src/types.rs` — FfiWaker::into_waker()
  - `crates/tau-tokio/src/lib.rs` — tokio shim JoinHandle, JoinError
  - `crates/tau-tokio/src/task/mod.rs` — AbortHandle, JoinSet, JoinNextFuture
  - `plugins/abort-test-plugin/src/lib.rs` — test plugin with cross-thread test
  - `tests/test-abort.sh`, `tests/test-abort.txt` — integration tests

### Per-task evaluation

**US-001 (FFI abort):** ✅ Clean. `abort_task()` sets aborted+completed, removes from ready_queue, cleans timers. Drop deferred to `take_completed()`.

**US-002 (tau crate wiring):** ✅ Elegant. `JoinHandle<T>` output is `Option<T>` (Some=success, None=abort). `WrapperFuture::drop` detects Running → Aborted transition, wakes JoinHandle. TaskCell ref-counting correct.

**US-003 (tokio shim):** ✅ Clean delegation. `AbortHandle` stores real `task_id`. `JoinSet::abort_all/shutdown/join_next` handle mixed completed/aborted results. `JoinSet::Drop` aborts all (matches tokio).

**US-004 (integration test):** ✅ Covers: abort idle task, abort completed task (no-op), Drop verification, cross-thread abort.

**US-004a (cross-thread abort):** ✅ ABORT_QUEUE pattern matches WAKE_QUEUE exactly. `queue_abort()` pushes + `try_notify_reactor()`. `prepare_drive()` drains. Always returns 1. Clean and consistent.

### Cross-task analysis (all 5 required checks)

1. **Abort during active polling / double-free:** ✅ SAFE. `tau_task_abort` queues to ABORT_QUEUE. Processed in NEXT `prepare_drive()`. During poll phase, the task is never simultaneously aborted+polled. `tasks.remove()` in `take_completed()` returns each task exactly once.

2. **Abort from spawn_blocking (cross-thread):** ✅ WORKS. ABORT_QUEUE is `OnceLock<Mutex<VecDeque<u64>>>` — thread-safe. `try_notify_reactor()` wakes the reactor from any thread. Test verified in abort-test-plugin "cross-thread-abort" command.

3. **plugin_task_count / drop_plugin_tasks:** ✅ CORRECT. `take_plugin_tasks` removes all tasks for a plugin (including aborted ones with completed=true). If aborts are pending in ABORT_QUEUE for already-removed tasks, `abort_task` returns false (task not found) — harmless no-op.

4. **Re-entrancy (aborting from within poll):** ✅ SAFE. `tau_task_abort` doesn't borrow RUNTIME at all — it pushes to a global Mutex queue. No RefCell involved. The abort is processed on the next drive cycle, after all polls complete.

5. **JoinSet::join_next with mixed results:** ✅ CORRECT. Tokio shim `JoinHandle::poll` maps `Some(val)→Ok(val)`, `None→Err(JoinError{cancelled:true})`. `JoinNextFuture` iterates with `swap_remove`. Both completed and aborted handles are handled uniformly.

### Quality assessment
- **Simplicity:** Excellent. Abort flow is straightforward: queue → drain → flag → cleanup → drop → notify JoinHandle. No unnecessary abstractions.
- **Correctness:** All acceptance criteria met. Abort is idempotent. Self-abort safe. Cross-thread safe.
- **Edge cases:** Handled through design (queue-based processing) not if/else patches.
- **Data structures:** ABORT_QUEUE mirrors WAKE_QUEUE — consistent pattern. Task HashMap, VecDeque, BTreeMap all appropriate.
- **Error handling:** Consistent. Abort of non-existent/completed tasks is a no-op.
- **Naming:** Clear and consistent across all layers.
- **Duplication:** Minor: `ffi_waker_to_std` in `tau-rt/src/runtime.rs` duplicates `FfiWaker::into_waker()` in `tau-rt/src/types.rs`. Pre-existing (not introduced by abort tasks). Will be addressed by US-018 (make_ffi_waker utility).

## Phase 1 review PASSED
- Learnings for future iterations:
  - The queue-based abort (ABORT_QUEUE) is strictly better than direct RUNTIME access — simpler, thread-safe, no special cases for self-abort vs cross-thread abort.
  - Two-level "completed" tracking: `Task.completed` (executor-side bool) vs `TaskCell.complete` (plugin-side AtomicBool) — different lifecycles, both correct. Task.completed controls executor scheduling; TaskCell.complete controls JoinHandle result availability.
  - `WrapperFuture::drop` is the critical bridge: host drops the erased future → plugin-side TaskCell transitions to Stage::Aborted → JoinHandle waker notified.
---
